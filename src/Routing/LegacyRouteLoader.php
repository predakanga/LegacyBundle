<?php

namespace TDW\LegacyBundle\Routing;

use Doctrine\Common\Annotations\CachedReader;
use Psr\Container\ContainerInterface;
use Symfony\Component\Config\ConfigCache;
use Symfony\Component\Config\Resource\FileResource;
use Symfony\Component\DependencyInjection\ServiceSubscriberInterface;
use Symfony\Component\HttpKernel\CacheWarmer\CacheWarmerInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Routing\RouterInterface;
use TDW\LegacyBundle\Util;

class LegacyRouteLoader implements ServiceSubscriberInterface, CacheWarmerInterface
{
    /**
     * @var RouterInterface
     */
    protected $symfonyRouter;
    /**
     * @var string
     */
    protected $cacheDir;
    /**
     * @var bool
     */
    protected $isDebug;
    /**
     * @var ContainerInterface
     */
    protected $locator;

    public function __construct(ContainerInterface $locator, RouterInterface $symfonyRouter, string $cacheDir, bool $isDebug)
    {
        $this->locator = $locator;
        $this->symfonyRouter = $symfonyRouter;
        $this->cacheDir = $cacheDir;
        $this->isDebug = $isDebug;
    }

    public function getRoutes(): array
    {
        $cachePath = $this->cacheDir.DIRECTORY_SEPARATOR.'legacy_routes.php';
        $routeCache = new ConfigCache($cachePath, $this->isDebug);

        if (!$routeCache->isFresh()) {
            $symfonyRoutes = $this->symfonyRouter->getRouteCollection();
            $symfonyResources = $symfonyRoutes->getResources();

            $routeBatches = [];
            foreach ($symfonyResources as $resource) {
                if ($resource instanceof FileResource && 'php' === strtolower(pathinfo($resource->getResource(), PATHINFO_EXTENSION))) {
                    $routeBatches[] = $this->loadRoutes($resource);
                }
            }

            $routes = [];
            if (\count($routeBatches)) {
                $routes = array_merge(...$routeBatches);
            }

            $cacheTemplate = <<<'CODE'
<?php

// This file has been autogenerated by LegacyBundle

return %s;
CODE;
            $routeCache->write(sprintf($cacheTemplate, var_export($routes, true)), $symfonyResources);
        }

        return require $cachePath;
    }

    protected function loadRoutes(FileResource $resource): array
    {
        $routes = [];
        /**
         * @var CachedReader
         */
        $reader = $this->locator->get('annotation_reader');
        foreach (Util::findClasses($resource->getResource()) as $fqcn) {
            $reflClass = new \ReflectionClass($fqcn);

            foreach ($reflClass->getMethods() as $reflMethod) {
                foreach ($reader->getMethodAnnotations($reflMethod) as $annotation) {
                    if ($annotation instanceof LegacyRoute) {
                        /**
                         * @var Route $symfonyRoute
                         */
                        $symfonyRoute = $reader->getMethodAnnotation($reflMethod, Route::class);
                        if (!$symfonyRoute || !$symfonyRoute->getName()) {
                            throw new \LogicException('LegacyRoute annotation must only be used together with a named Route annotation');
                        }
                        $routes[] = $this->createRoute($annotation, $symfonyRoute->getName());
                    }
                }
            }
        }

        // Before returning them, group and sort the routes
        $sortedRoutes = [];
        foreach($routes as $route) {
            if(!isset($sortedRoutes[$route['path']])) {
                $sortedRoutes[$route['path']] = [];
            }
            $sortedRoutes[$route['path']][] = $route;
        }
        foreach(array_keys($sortedRoutes) as $path) {
            usort($sortedRoutes[$path], function($routeA, $routeB) {
                $countA = \count($routeA['get']) + \count($routeA['post']);
                $countB = \count($routeB['get']) + \count($routeB['post']);

                if ($countA === $countB) {
                    return 0;
                }

                // N.B. Because we want largest first, the below comparison is flipped from the usual
                if($countA < $countB) {
                    return 1;
                } else {
                    return -1;
                }
            });
        }

        return $sortedRoutes;
    }

    protected function createRoute(LegacyRoute $annotation, string $routeName): array
    {
        $url = $annotation->value;
        $urlParts = parse_url($url);
        $queryVars = [];
        parse_str($urlParts['query'] ?? '', $queryVars);
        $queryVars = array_merge($queryVars, $annotation->getVars ?? []);

        return ['path' => $urlParts['path'], 'get' => $queryVars, 'post' => $annotation->postVars ?? [], '_route' => $routeName];
    }

    /**
     * {@inheritdoc}
     */
    public static function getSubscribedServices(): array
    {
        return ['annotation_reader'];
    }

    /**
     * {@inheritdoc}
     */
    public function warmUp($cacheDir): void
    {
        // Temporarily override the main cache dir
        $origCacheDir = $this->cacheDir;
        $this->cacheDir = $cacheDir;

        // And load the routes
        try {
            $this->getRoutes();
        } finally {
            // Before restoring the original cache dir
            $this->cacheDir = $origCacheDir;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function isOptional(): bool {
        return true;
    }
}
